<?xml version="1.0" encoding="utf-8"?>
<!--
///////////////////////////////////////////////////////////////////////////////////
// 
//  Copyright (c) 2014 Nailson <nailsonnego@gmail.com>
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
// 
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////////
-->

<s:Window xmlns:fx="http://ns.adobe.com/mxml/2009" 
          xmlns:s="library://ns.adobe.com/flex/spark" 
          xmlns:mx="library://ns.adobe.com/flex/mx"
          xmlns:nail="library://ns.nail.com/naillib"
          xmlns:components="nail.otlib.components.*"
          width="800"
          height="600"
          minWidth="600"
          minHeight="400"
          fontSize="11"
          backgroundColor="0x494949"
          showStatusBar="false"
          title="Slicer">
    
    <fx:Declarations>
        <fx:XMLList id="menuXML">
            <menuitem label="{resourceManager.getString('strings', 'menu.file')}">
                <menuitem label="{resourceManager.getString('strings', 'menu.open')}" data="fileOpen" keyEquivalent='O' icon="nail.assets.Icons_OPEN"/>
            </menuitem>
        </fx:XMLList>
    </fx:Declarations>
    
    <s:layout>
        <s:VerticalLayout/>
    </s:layout>
    
    <fx:Metadata>
        [ResourceBundle("strings")]
    </fx:Metadata>
    
    <fx:Script>
        <![CDATA[
            import mx.collections.ArrayCollection;
            import mx.events.MenuEvent;
            import mx.events.MoveEvent;
            import mx.managers.DragManager;
            
            import nail.assets.NailAssets;
            import nail.codecs.ImageCodec;
            import nail.components.controls.Alert;
            import nail.objectbuilder.core.IObjectBuilder;
            import nail.objectbuilder.utils.ObUtils;
            import nail.otlib.components.SurfaceCells;
            import nail.otlib.sprites.Sprite;
            import nail.otlib.utils.SpriteUtils;
            import nail.utils.FileUtil;
            
            //--------------------------------------------------------------------------
            // PROPERTIES
            //--------------------------------------------------------------------------
            
            public var application:IObjectBuilder;
            public var lastDirectory:File;
            
            [Bindable]
            private var _sprites:ArrayCollection = new ArrayCollection();
            private var _surfaceCells:SurfaceCells;
            private var _rect:Rectangle = new Rectangle();
            private var _file:File;
            private var _fileChanged:Boolean;
            private var _bitmap:BitmapData;
            private var _nextBitmap:BitmapData;
            private var _bitmapChanged:Boolean;
            private var _mouseDown:Boolean;
            private var _zoom:Number;
            private var _zoomChanged:Boolean;
            private var _lastValues:Rectangle = new Rectangle();
            private var _transparency:Boolean;
            
            //--------------------------------------
            // Getters / Setters 
            //--------------------------------------
            
            public function get file():File { return _file; }
            public function set file(value:File):void
            {
                _file = value;
                _fileChanged = true;
                invalidateProperties();
            }
            
            public function get bitmap():BitmapData { return _bitmap; }
            public function set bitmap(value:BitmapData):void
            {
                if (_bitmap != value) {
                    _nextBitmap = value;
                    _bitmapChanged = true;
                    invalidateProperties();
                }
            }
            
            public function get hasImage():Boolean { return (_bitmap || (imageControl && imageControl.source)); }
            
            [Bindable]
            public function get zoom():Number { return _zoom; }
            public function set zoom(value:Number):void
            {
                if (_zoom != value && value >= zoomSlider.minimum && value <= zoomSlider.maximum) {
                    _zoom = value;
                    _zoomChanged = true;
                    invalidateProperties();
                }
            }
            
            public function get bitmapList():Vector.<BitmapData>
            {
                var length:uint = _sprites.length;
                if (length > 0) {
                    var list:Vector.<BitmapData> = new Vector.<BitmapData>(length, true);
                    for (var i:uint = 0; i < length; i++) {
                        list[i] = _sprites.getItemAt(i) as BitmapData;
                    }
                    return list;
                }
                return null;
            }
            
            public function get transparency():Boolean { return _transparency; }
            public function set transparency(value:Boolean):void { _transparency = value; }
            
            //--------------------------------------------------------------------------
            // METHODS
            //--------------------------------------------------------------------------
            
            //--------------------------------------
            // Protected
            //--------------------------------------
            
            protected function update():void
            {
                if (!this.hasImage) return;
                
                var size:uint = nail.otlib.sprites.Sprite.SPRITE_PIXELS;
                _surfaceCells.cellWidth = size;
                _surfaceCells.cellHeight = size;
                _surfaceCells.columns = columnsStepper.value;
                _surfaceCells.rows = rowsStepper.value;
                
                var sw:uint = (size * _surfaceCells.columns);
                var sh:uint = (size * _surfaceCells.rows);
                var dx:int = (_surfaceCells.x + sw) - this.bitmap.width;
                var dy:int = (_surfaceCells.y + sh) - this.bitmap.height;
                var up:Boolean;
                
                if (dx > 0) {
                    _surfaceCells.x -= dx;
                    up = true;
                }
                
                if (dy > 0) {
                    _surfaceCells.y -= dy;
                    up = true;
                }
                
                if (_surfaceCells.x < 0) {
                    _surfaceCells.x = 0;
                    up = true;
                }
                
                if (_surfaceCells.y < 0) {
                    _surfaceCells.y = 0;
                    up = true;
                }		
                
                if (up) {
                    offsetXStepper.value = _surfaceCells.x;
                    offsetYStepper.value = _surfaceCells.y;
                }
                
                offsetXStepper.maximum = this.bitmap.width - sw;
                offsetYStepper.maximum = this.bitmap.height - sh;
                columnsStepper.maximum = Math.floor(this.bitmap.width / size);
                rowsStepper.maximum = Math.floor(this.bitmap.height / size);
            }
            
            protected function onCutImage():void
            {
                if (!this.hasImage) return;
                
                var x:int = offsetXStepper.value;
                var y:int = offsetYStepper.value;
                var width:uint = nail.otlib.sprites.Sprite.SPRITE_PIXELS;
                var height:uint = nail.otlib.sprites.Sprite.SPRITE_PIXELS;
                var columns:uint = columnsStepper.value;
                var rows:uint = rowsStepper.value;
                
                // Returns if the values ​​have not changed.
                if (_sprites.length != 0 &&
                    _lastValues.x == x &&
                    _lastValues.y == y &&
                    _lastValues.width == columns &&
                    _lastValues.height == rows) {
                    return;
                }
                
                var rect:Rectangle = new Rectangle(0, 0, width, height);
                var point:Point = new Point();
                
                _lastValues.setTo(x, y, columns, rows);
                
                for (var c:uint = 0; c < columns; c++) {
                    for (var r:uint = 0; r < rows; r++) {
                        rect.x = x + (c * width);
                        rect.y = y + (r * height);
                        
                        var sprite:BitmapData;
                        if (_transparency)
                            sprite = new BitmapData(width, height, true, 0xFFFF00FF);
                        else
                            sprite = new BitmapData(width, height, false, 0xFF00FF);
                        
                        sprite.copyPixels(this.bitmap, rect, point);
                        sprite = SpriteUtils.removeMagenta(sprite);
                        
                        if (!SpriteUtils.isEmpty(sprite)) {
                            _sprites.addItem(sprite);
                        }
                    }
                }
            }
            
            protected function resetControls():void
            {
                offsetXStepper.value = 0;
                offsetYStepper.value = 0;
                columnsStepper.value = 1;
                rowsStepper.value = 1;
                zoomSlider.value = 1.0;
                zoom = 1.0;
                _surfaceCells.x = 0;
                _surfaceCells.y = 0;
            }
            
            protected function importImagesFromFiles(list:Vector.<File>):void
            {
                ImageCodec.decodeFromFile(list[0], imageDecodeCallback);
                
                function imageDecodeCallback(bitmap:BitmapData):void
                {
                    setBitmap(bitmap);
                }
            }
            
            //--------------------------------------
            // Override Protected
            //--------------------------------------
            
            override protected function createChildren():void
            {
                super.createChildren();
                
                _surfaceCells = new SurfaceCells();
                _surfaceCells.blendMode = BlendMode.INVERT;
                _surfaceCells.addEventListener(MouseEvent.MOUSE_DOWN, surfaceCellsMouseDownHandler);
                _surfaceCells.addEventListener(MouseEvent.MOUSE_UP, surfaceCellsMouseUpHandler);
                _surfaceCells.addEventListener(MoveEvent.MOVE, surfaceCellsMoveHandler);
                imageConteinerGroup.addElement(_surfaceCells);
            }
            
            override protected function commitProperties():void
            {
                super.commitProperties();
                
                if (_fileChanged) {
                    setFile(_file);
                    _fileChanged = false;
                }
                
                if (_bitmapChanged) {
                    setBitmap(_nextBitmap);
                    _nextBitmap = null;
                    _bitmapChanged = false;
                }
                
                if (_zoomChanged) {
                    imageConteinerGroup.scaleX = _zoom;
                    imageConteinerGroup.scaleY = _zoom;
                    _zoomChanged = false;
                }
            }
            
            //--------------------------------------
            // Private
            //--------------------------------------
            
            private function setFile(file:File):void
            {
                if (!file || !FileUtil.hasBitmapFormat(file)) return;
                
                try
                {
                    ImageCodec.decodeFromFile(file, imageReadCallback);
                    lastDirectory = FileUtil.getDirectory(file);
                } catch(error:Error) {
                    Alert.show(error.getStackTrace(), resourceManager.getString("strings", "error"), Alert.OK, this);
                }
                
                function imageReadCallback(bitmap:BitmapData):void
                {
                    setBitmap(bitmap);
                }
            }
            
            private function setBitmap(bitmap:BitmapData):void
            {
                _bitmap = bitmap;
                imageControl.source = bitmap;
                
                resetControls();
                update();
            }
            
            private function onOpenFile():void
            {
                var filters:Array = ObUtils.createImagesFileFilter();
                var file:File = lastDirectory ? new File(lastDirectory.nativePath) : File.userDirectory;
                file.addEventListener(Event.SELECT, fileSelectHandler);
                file.browseForOpen(resourceManager.getString("strings", "selectImage"), filters);
                
                function fileSelectHandler(event:Event):void
                {
                    setFile(file);
                }
            }
            
            //--------------------------------------
            // Event Handlers
            //--------------------------------------
            
            protected function imageContainerMouseMoveHandler(event:MouseEvent):void
            {
                if (_bitmap && _mouseDown) {
                    offsetXStepper.value = _surfaceCells.x;
                    offsetYStepper.value = _surfaceCells.y;
                }
            }
            
            protected function imageContainerMouseDownHandler(event:MouseEvent):void
            {
                if (!this.hasImage) return;
                
                if (event.target != _surfaceCells && event.localX <= this.bitmap.width && event.localY <= this.bitmap.height) {
                    var px:Number = Math.round(event.localX - _surfaceCells.width * 0.5);
                    var py:Number = Math.round(event.localY - _surfaceCells.height * 0.5);
                    
                    _surfaceCells.move(px, py);
                    
                    update();
                    surfaceCellsMouseDownHandler(event);
                }
            }
            
            protected function imageConteinerGroupNativeDragEnterHandler(event:NativeDragEvent):void
            {
                if (event.target == imageConteinerGroup) {
                    if (event.clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT)) {
                        NativeDragManager.dropAction = NativeDragActions.LINK;
                        DragManager.acceptDragDrop(imageConteinerGroup);
                    }
                }
            }
            
            protected function imageConteinerGroupNativeDragDropHandler(event:NativeDragEvent):void
            {
                var clipboard:Clipboard = event.clipboard;
                if (clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT)) {
                    var dropfiles:Array = clipboard.getData(ClipboardFormats.FILE_LIST_FORMAT) as Array;
                    
                    FileUtil.sortFiles(dropfiles, Array.NUMERIC | Array.DESCENDING);
                    
                    var length:uint = dropfiles.length;
                    var list:Vector.<File> = new Vector.<File>();
                    for (var i:uint = 0; i < length; i++) {
                        var file:File = dropfiles[i];
                        if (FileUtil.hasBitmapFormat(file)) {
                            list[list.length] = file;
                        }
                    }
                }
                
                if (list.length > 0) {
                    importImagesFromFiles(list);
                }
            }
            
            protected function surfaceCellsMouseDownHandler(event:MouseEvent):void
            {
                _mouseDown = true;
                
                _rect.width  = imageControl.width - _surfaceCells.width;
                _rect.height = imageControl.height - _surfaceCells.height;
                
                cursorManager.setCursor(NailAssets.MOVE_CURSOR, 2, -8, -8);
                
                _surfaceCells.startDrag(false,_rect);
                
                systemManager.stage.addEventListener(MouseEvent.MOUSE_UP, surfaceCellsMouseUpHandler);
            }
            
            protected function surfaceCellsMouseUpHandler(event:MouseEvent):void
            {
                systemManager.stage.removeEventListener(MouseEvent.MOUSE_UP, surfaceCellsMouseUpHandler);
                
                _mouseDown = false;
                
                _surfaceCells.stopDrag();
                
                cursorManager.removeCursor(cursorManager.currentCursorID);
            }
            
            protected function surfaceCellsMoveHandler(event:MoveEvent):void
            {
                _surfaceCells.x = Math.round(_surfaceCells.x);
                _surfaceCells.y = Math.round(_surfaceCells.y);
            }
            
            protected function offsetStepperChangeHandler(event:Event):void
            {
                _surfaceCells.x = offsetXStepper.value;
                _surfaceCells.y = offsetYStepper.value;
            }
            
            protected function zoomChangeHandler(event:Event):void
            {
                this.zoom = HSlider(event.target).value;
            }
            
            protected function menuItemClickHandler(event:MenuEvent):void
            {
                var data:String = String(event.item.@data);
                switch(data) {
                    case "fileOpen":
                        this.onOpenFile();
                        break;
                }
            }
            
            protected function importButtonClickHandler(event:MouseEvent):void
            {
                var length:uint = _sprites.length;
                if (length > 0) {
                    var rect:Rectangle = new Rectangle(0, 0, 32, 32);
                    var list:Vector.<ByteArray> = new Vector.<ByteArray>(length, true);
                    for (var i:uint = 0; i < length; i++) {
                        var bitmap:BitmapData = _sprites.getItemAt(i) as BitmapData;
                        list[i] = bitmap.getPixels(rect);;
                    }
                    application.importSprites(list);
                }
            }
            
            protected function clearButtonClickHandler(event:MouseEvent):void
            {
                _sprites.removeAll();
            }
            
        ]]>
    </fx:Script>
    
    <!-- menu bar -->
    <s:Group width="100%"
             height="31">
        <!-- fill -->
        <s:Rect left="-1" right="-1" top="1" bottom="0">
            <s:fill>
                <s:SolidColor color="0x494949"/>
            </s:fill>
        </s:Rect>
        
        <!-- border -->
        <s:Rect left="-1" right="-1" top="0" bottom="0">
            <s:stroke>
                <s:SolidColorStroke color="0x272727"/>
            </s:stroke>
        </s:Rect>
        
        <mx:MenuBar id="menuBar"
                    width="100%"
                    top="4"
                    fontSize="11"
                    labelField="@label"
                    iconField="@icon"
                    showRoot="true"
                    dataProvider="{menuXML}"
                    itemSkin="nail.components.skins.MenuBarItemSkin"
                    itemClick="menuItemClickHandler(event)"/>
    </s:Group>
    
    <s:HGroup width="100%"
              height="100%">
        <s:BorderContainer width="150"
                           height="100%"
                           skinClass="nail.components.skins.BorderContainerSkin">
            <s:layout>
                <s:VerticalLayout paddingLeft="5"
                                  paddingRight="5"
                                  paddingTop="10"
                                  paddingBottom="10"
                                  verticalAlign="bottom"/>
            </s:layout>
            
            <nail:GroupBox label="@Resource(key='cells', bundle='strings')"
                           width="100%">
                <nail:layout>
                    <s:VerticalLayout paddingLeft="5"
                                      paddingRight="5"
                                      paddingTop="10"
                                      paddingBottom="10"/>
                </nail:layout>
                <s:TileGroup width="100%"
                             requestedColumnCount="2"
                             verticalAlign="middle">
                    <s:Label text="X:"
                             textAlign="right"/>
                    <s:NumericStepper id="offsetXStepper"
                                      width="55"
                                      minimum="0"
                                      maximum="608"
                                      change="offsetStepperChangeHandler(event)"/>
                    <s:Label text="Y:"
                             textAlign="right"/>
                    <s:NumericStepper id="offsetYStepper"
                                      width="55"
                                      minimum="0"
                                      maximum="608"
                                      change="offsetStepperChangeHandler(event)"/>
                    <s:Label text="{resourceManager.getString('strings', 'columns') + ':'}"
                             textAlign="right"/>
                    <s:NumericStepper id="columnsStepper"
                                      width="55"
                                      minimum="1"
                                      maximum="20"
                                      change="update()"/>
                    <s:Label text="{resourceManager.getString('strings', 'rows') + ':'}"
                             textAlign="right"/>
                    <s:NumericStepper id="rowsStepper"
                                      width="55"
                                      minimum="1"
                                      maximum="20"
                                      change="update()"/>
                </s:TileGroup>
            </nail:GroupBox>
            
            <nail:GroupBox label="@Resource(key='zoom', bundle='strings')"
                           width="100%">
                <nail:layout>
                    <s:VerticalLayout paddingLeft="5"
                                      paddingRight="5"
                                      paddingTop="10"
                                      paddingBottom="10"/>
                </nail:layout>
                <s:HSlider id="zoomSlider"
                           width="100%"
                           minimum="1.0"
                           maximum="5.0"
                           stepSize="0.1"
                           value="{zoom}"
                           bottom="10"
                           right="10"
                           change="zoomChangeHandler(event)"/>
            </nail:GroupBox>
            
            <s:Spacer height="3"/>
            <nail:ShadowLine width="100%"/>
            <s:Spacer height="3"/>
            
            <s:Button id="cutButton"
                      label="@Resource(key='crop', bundle='strings')"
                      width="100%"
                      click="onCutImage()"/>
        </s:BorderContainer>
        
        <s:BorderContainer width="100%"
                           height="100%"
                           skinClass="nail.components.skins.BorderContainerSkin">
            <s:layout>
                <s:VerticalLayout paddingLeft="1"
                                  paddingRight="0"
                                  paddingTop="1"
                                  paddingBottom="0"/>
            </s:layout>
            <s:Scroller width="100%"
                        height="100%"
                        verticalScrollPolicy="on"
                        horizontalScrollPolicy="on">
                
                <s:Group id="imageConteinerGroup"
                         width="100%"
                         height="100%"
                         mouseMove="imageContainerMouseMoveHandler(event)"
                         mouseDown="imageContainerMouseDownHandler(event)"
                         nativeDragEnter="imageConteinerGroupNativeDragEnterHandler(event)"
                         nativeDragDrop="imageConteinerGroupNativeDragDropHandler(event)">
                    
                    <components:CheckerBoard id="checkerboard"
                                             width="{imageControl.width}"
                                             height="{imageControl.height}"/>
                    
                    <s:Image id="imageControl"/>
                    
                    <s:SpriteVisualElement id="surfaceLine"
                                           width="100%"
                                           height="100%"
                                           blendMode="invert"/>	
                </s:Group>
            </s:Scroller>
        </s:BorderContainer>
        
        <s:BorderContainer width="150"
                           height="100%"
                           skinClass="nail.components.skins.BorderContainerSkin">
            <s:layout>
                <s:VerticalLayout paddingLeft="5"
                                  paddingRight="5"
                                  paddingTop="10"
                                  paddingBottom="10"/>
            </s:layout>
            
            <nail:GroupBox label="@Resource(key='sprites', bundle='strings')"
                           width="100%"
                           height="100%">
                <s:List width="100%"
                        height="100%"
                        contentBackgroundColor="0x494949"
                        borderVisible="false"
                        dataProvider="{_sprites}"
                        itemRenderer="nail.otlib.components.renders.BitmapListRenderer"/>
            </nail:GroupBox>
            
            <s:Spacer height="3"/>
            <nail:ShadowLine width="100%"/>
            <s:Spacer height="3"/>
            
            <s:Button id="importButton"
                      label="@Resource(key='import', bundle='strings')"
                      width="100%"
                      enabled="{_sprites.length > 0}"
                      click="importButtonClickHandler(event)"/>
            <s:Button id="clearButton"
                      label="@Resource(key='clear', bundle='strings')"
                      width="100%"
                      click="clearButtonClickHandler(event)"/>
        </s:BorderContainer>
    </s:HGroup>
</s:Window>
